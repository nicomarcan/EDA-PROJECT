package TPE;



public class AVL<T extends Comparable<? super T>> {
 
  private static class Node<T> {
	  private T elem;
	  private Node<T> left;
	  private Node<T> right;
	  private int height;
    
  
    public Node (T elem){
      this.elem = elem;
    } 
  }

  public Node<T> root;
  
  public int countInsertions;
  public int countSingleRotations;
  public int countDoubleRotations;
  
 
  public int height (Node<T> t){
    return t == null ? -1 : t.height;
  }
  
 
  public int max (int a, int b){
    return a > b ? a : b;
  }
  

  public boolean insert(T elem){
      root = insert(elem, root);
      countInsertions++;
      return true;
  }
  
 
  private Node<T> insert (T elem, Node<T> current) {
	    if (current == null)
	    	current = new Node<T> (elem);
	    else if (elem.compareTo(current.elem) <= 0){
	    	current.left = insert(elem, current.left);
	      
	     if (height(current.left) - height(current.right) > 1){
	        if (elem.compareTo (current.left.elem) < 0){
	          current = rotateWithLeftChild(current);
	          countSingleRotations++;
	        }
	        else {
	          current = doubleWithLeftChild(current);
	          countDoubleRotations++;
	        }
	      }
	    }
	    else if (elem.compareTo(current.elem) > 0){
		      current.right = insert(elem, current.right);   
		      if ( height(current.right) - height(current.left) > 1)
		        if (elem.compareTo(current.right.elem) > 0){
		          current = rotateWithRightChild(current);
		          countSingleRotations++;
		        }
		        else{
		          current = doubleWithRightChild(current);
		          countDoubleRotations++;
		        }
	    }       
	    current.height = max (height(current.left), height(current.right)) + 1;
	    return current;
  }
  

  private Node<T> rotateWithLeftChild (Node<T> n){
    Node<T> aux = n.left;
    n.left = aux.right;
    aux.right = n;
    n.height = max (height (n.left), height(n.right)) + 1;
    aux.height = max(height (aux.left), n.height) + 1;  
    return aux;
  }
  

  private Node<T> doubleWithLeftChild (Node<T> n){
    n.left = rotateWithRightChild(n.left);
    return rotateWithLeftChild (n);
  }
  
  private Node<T> rotateWithRightChild (Node<T> n){
    Node<T> aux = n.right;   
    n.right = aux.left;
    aux.left = n;   
    aux.height = max (height(aux.left), height(aux.right)) + 1;
    n.height = max (height (n.right), n.height) + 1; 
    return aux;
  }

 
  private Node<T> doubleWithRightChild (Node<T> n){
    n.right = rotateWithLeftChild (n.right);
    return rotateWithRightChild (n);
  }

  public boolean isEmpty(){
    return root == null;
  }

  public T findMin(){
      if(isEmpty()) 
    	  return null;
       return findMin(root).elem;
   }

 
    public Box<T> findMaxAndRemoveNode(Node<T> node){
        if(isEmpty())
        	return null;
        
        return findMaxAndRemoveNode(node,false);
       
    }

 
    private Node<T> findMin(Node<T> current){
        if(current == null)
            return current;
        while( current.left != null )
            current = current.left;
        return current;
    }

    private static class Box<T>{
    	Node<T> node ;
    	T max;
    	
    	public Box(T max,Node<T> node){
    		this.max = max;
    		this.node = node;
    	}
    	
    	
    }
    private Box<T> findMaxAndRemoveNode(Node<T> current,boolean found)    {
        if( current == null )
            return new Box<T>(null,current);
        Box<T> b = findMaxAndRemoveNode(current.right,found);
        current.right = b.node;
        if(current.right == null && !found){
        	found = true;
        	return new Box<T>(current.elem,current.left);
        }
        return new Box<T>(b.max,current);
    }



  public void remove( T x ) {
      root = remove(x, root);
  }

  private Node<T> remove(T elem, Node<T> current) {
	  if(current == null){
			return null;
		}
		int c = elem.compareTo(current.elem);
		if(c > 0){
			current.right = remove(elem,current.right);
			return current;
		}else if(c < 0){
			current.left = remove(elem,current.left);
			return current;
		}
		if(current.right == null && current.left == null)
			return null;
		if(current.right != null && current.left == null)
			return current.right;
		if(current.left != null && current.right == null)
			return current.left;
		Box<T> b = findMaxAndRemoveNode(current.left);
		current.left = b.node;
		current.elem = b.max;
		return current;
  } 


  public boolean contains(T elem){
    return contains(elem, root); 
  }


  private boolean contains(T elem, Node<T> current) {
    if (current == null)
    	return false; 
    
    else if (elem.compareTo(current.elem) < 0)
    	 return contains(elem, current.left);
    
    else if (elem.compareTo(current.elem) > 0)
    	 return contains(elem, current.right);
    
    return true; 
  }
  public void print(){
		print(root);
	}
	private  void print(Node<T> current){
		if(current.left == null && current.right == null ){
			System.out.println(current.elem);
			return;
		}else if (current.left!= null && current.right != null){
			System.out.println("Padre: "+current.elem+", Hijo izquierdo: "+current.left.elem+",Hijo derecho: "+current.right.elem);
			print(current.left);
			print(current.right);
		}else if(current.left != null){
			System.out.println("Padre: "+current.elem+", Hijo izquierdo: "+current.left.elem);
			print(current.left);
		}else{
			System.out.println("Padre: "+current.elem+",Hijo derecho: "+current.right.elem);
			print(current.right);
		}
		
	}
	public static void main(String[] args) {
		AVL<Integer> tree = new AVL<Integer>();
		tree.insert(2);
		tree.insert(3);
		tree.insert(4);
		tree.insert(5);
		tree.insert(6);
		tree.print();
	}
  

 
}