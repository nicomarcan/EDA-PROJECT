package TPE;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.TreeSet;

import TPE.AirportManager.Node;

public class PathFinder {
	public static List<Flight> findPath(Set<Node> airports,Node source,Node dest,List<Day> departDays){
		Set<Integer> interval = new TreeSet<Integer>();
		Set<Node> posibleAirports = new HashSet<Node>();
 		for(int i = 0;i<departDays.size();i++){
			for(Node a : airports){
				if(!a.equals(source)){
					for(Flight f : source.priceFlight.get(a.airport).get(departDays.get(i))){
						interval.add(f.getDepartureTime()+f.getCurrentDayIndex()*60*24);
					}
				}
			}
		}
		 Map<Node,ArriveFunction> af = timeRefinement(airports,source,dest,interval);
	}

	private static Map<Node,ArriveFunction> timeRefinement(Set<Node> airports, Node source, Node dest,
			ArrayList<Integer> interval) {
		
		Map<Node,ArriveFunction> res = new HashMap<Node,ArriveFunction>();
		ArrayList<Integer> subInterval = new ArrayList<Integer>();
		int j = 0;
		subInterval.add(interval.get(j++));
		
		for(Node airport : airports){
			if(!airport.equals(source)){
				ArriveFunction a = new ArriveFunction(source,airport);
				for(Integer i : subInterval){
					a.getDepartToArrival().put(i, Integer.MAX_VALUE);
				}
				res.put(airport,a);
			}else{
				ArriveFunction a = new ArriveFunction(source,source);
				for(Integer i : subInterval){
					a.getDepartToArrival().put(i, i);
				}
				res.put(source,a);
			}
		}
			PriorityQueue<Entry> pq = new PriorityQueue<Entry>();
			for(ArriveFunction a : res.values()){
				pq.offer(new Entry(subInterval.get(j),a));
			}
			while(pq.size() > 2){
				Entry i = pq.poll();
				Entry head = pq.peek();
				Integer minEdgeW = getMinEdgeW(airports,head.af.getDepartToArrival().get(head.time),i);
				Integer maxT = getMaxT(j,interval,minEdgeW,head,i);
				
				for(Node n : airports){
					for(Flight f : i.af.getDst().waitingTimes.get(n.airport)){
						for(int k = j;k<=maxT;k++){
							Integer gI = i.af.getDepartToArrival().get(k);
							Integer aux = gI + i .af.getDst().waitingTimes.get(n.airport).earliestArrivalTime(gI).getFlightTime();
							if(res.get(n).getDepartToArrival().get(k) > aux){
								res.get(n).getDepartToArrival().put(k, aux);
							}
						}
						pq.update();
						
						
					}
				}
				j = maxT;
				if(maxT == interval.get(interval.size()-1)){
					return res;
				}else{
					pq.offer(new Entry (j,i.af));				
				}
				
					
				}
				
				
				
				return res;
			}
		
		
		
	

	
	

	

	private static Integer getMaxT(int j, ArrayList<Integer> interval, Integer minEdgeW, Entry head, Entry i) {
		while(i.af.getDepartToArrival().get(interval.get(j)) <= head.af.getDepartToArrival().get(head.time)+minEdgeW){
			j++;
		}
		return j;
	}

	private static Integer getMinEdgeW(Set<Node> airports ,Integer time, Entry i) {
		Integer min = Integer.MAX_VALUE;
		for(Node n : airports){
			Integer current = n.waitingTimes.get(i.af.getDst()).earliestArrivalTime(time).getFlightTime();
			if(current.compareTo(min)<0){
				min = current;
			}
		}
		return min;
		
	}

	private static class Entry implements Comparable<Entry>{
		private Integer time;
		private ArriveFunction af;
		
		public Entry(Integer time, ArriveFunction af) {
			super();
			this.time = time;
			this.af = af;
		}

		@Override
		public int compareTo(Entry o) {
			return this.af.getDepartToArrival().get(time)   -o.af.getDepartToArrival().get(time);
		}
		
		
	}
	


}

