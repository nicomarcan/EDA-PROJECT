package TPE;

import java.util.Comparator;

@SuppressWarnings("unchecked")
public class Heap<T> {
	
	
	private static int getParent(int index) {
		return (index-1)/2;
	}

	private static int getLeft(int index) {
		return index*2+1;
	}

	private static int getRight(int index) {
		return index*2+2;
	}
	
	private static<E> int moveUp(E[] array,int index,Comparator<E> cmp){
		int parent = getParent(index);
		E elem = array[index];
		while(index !=0 && cmp.compare(elem,array[parent]) > 0){
			array[index] = array[parent];
			index = parent;
			parent = getParent(index);
		}
		array[index] = elem;
		return index;
	}
	
	private static<E> int moveDown(E[] array,int index,int size,Comparator<E> cmp){
		int maxChild = getMaxChild(array,index,size,cmp);
		if(maxChild == -1){
			return index;
		}
		E elem = array[index];
		while(maxChild != -1 && cmp.compare(elem, array[maxChild]) < 0){
			array[index] = array[maxChild];
			index = maxChild;
			maxChild = getMaxChild(array,index,size,cmp);
		}
		array[index] = elem;
		return index;
	}
	
	private static<E> int getMaxChild(E[]array,int index,int size,Comparator<E> cmp){
		int leftChild = getLeft(index);
		int rightChild = getRight(index);
		if(leftChild >= size){
			return -1;//no tiene hijos
		}
		if(rightChild == size){
			return leftChild;
		}
		return cmp.compare(array[rightChild], array[leftChild]) > 0 ? rightChild : leftChild;
	}

/****************************** FIN FUNCIONES STATIC ***********************************/
	private Object[] heap;
	private int size;
	private Comparator<T> cmp;
	public Heap( int size, Comparator<T> cmp) {
		this.heap = new Object[size] ;
		this.cmp = cmp;
	}
	public Heap( Object[] heap  ,Comparator<T> cmp) {
		this.heap = heap ;
		this.cmp = cmp;
	}
	public Heap( int size) {
		this.heap = new Object[size] ;
	}
	
	public void insert(T elem){
		if(size == heap.length){
			throw new RuntimeException();
		}
		int elemIndex = size++;
		heap[elemIndex] = elem;
		balanceHeapIn(elemIndex);
	}
	
	public void remove(T elem){
		int index = getIndexOf(elem);
		if(index == -1){
			return;
		}
		heap[index] = heap[size-1];
		size--;
		balanceHeapRem(index);
	}
	
	public void remove(int index){
		heap[index] = heap[size-1];
		heap[--size] = null;
		balanceHeapRem(index);
	}

	private void balanceHeapIn(int index) {
		moveUp((T[])heap,index,cmp);
	}
	
	private void balanceHeapRem(int index){
		moveDown((T[]) heap,index,size,cmp);
	}
	
	private int getIndexOf(T elem){
		for(int i = 0;i< size;i++){
			if(cmp.compare(elem, (T)heap[i]) == 0){
				return i;
			}
		}
		return -1;
	}
	public void print() {
		StringBuffer s = new StringBuffer();
		s.append('[');
		for(int i = 0; i < size; i++){
			String s2 = " " + (T)heap[i]+",";
			s.append(s2);
		}
		s.append(']');
		System.out.println(s.toString());
	}


	
		
	}

	